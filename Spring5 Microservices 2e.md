# 책 제목 : Spring5 Microservices 2e 
(스피링5 마이크로서비스 second edition) 에이콘출판사 

# 01. 쉽게알아보는 마이크로서비스 

* 용어 
  * 마이크로서비스 : 현대 비즈니스 요건에 적합한 소프트웨어 개발에 대한 아키텍처 스타일 또는 접근방식임. 기존 스타일에서 진화한 것임
  * DevOps : Development 와 Operations의 합성어로서 개발환경/문화를 말함
  * Agility : 좋은 것을 빠르고 낭비없이 만드는 것

* 기술 패러다임의 변화 
   * RDBMS -> NoSQL DB 
   * HTML, CSS3 -> Angular, Ember, Backbone 등 클라이언트 JavaScript 는 반응형  (Responsive) 및 적응형(adaptive) 디자인으로 발전
   * Cloud - Pivotal Cloud Foundry, AWS, Salesforce, IBM bluemix, Redhat Openshift 등 서비스플랫폼(PaaS) 
   * 인프라스트럭처 - Docker

* 마이크로서비스의 특징
   * MS는 서비스종단점을 API형태로 노출하고 실질적인 세부사항은 모두 추상화함
   * SOA 특징 적용됨
     - JSON/REST등 서비스 규격, 느슨한 결합, 서비스 추상화, 서비스재사용, 탐색가능한 Discovery서비스, 서비스호환성은 표준프로토콜과 메시지 교환 준수, 서비스조립성은 Orchestration 등을 통해 확보 가능
   * MS는 가볍다 
     - 도커와 같은 컨테이너 기술, Jetty/Tomcat과 같은 App 컨테이너, 이식성이 뛰어남
   * 다양한 언어로 구성할 수 있는 MS 
     - 서로 다른 서비스는 java 버전, 언어, 아키텍처(Redis, MySQL 등 DataStore등)가 다를 수 있음
   * MS 환경에서의 자동화 
     - 형상관리도구(Git, Bitbuket), 지속적 통합(Jenkins,Travis), 테스트(Selenuim,Cucumber), 인프라스트럭처 프로비저닝(사용자 요구에 맞게 시스템 자원 할당,배치,배포해두었다가 필요시 즉시 사용할 수 있는 상태로 미리 준비해 두는 것), 릴리스관리도구9Chef,Puppet),배포도구(Spring Cloud, Kubernetes, Mesos) 
   * MS를 지원하는 생태계
     - 데브옵스 프로세스, 중앙집중식 로그관리, 서비스 레지스트리, API게이트웨이, 모니터링, 서비스라우팅, 작업흐름통제 메커니즘 등 
   * 동적이고 분산되어 있는 MS 
     - 데이터 및 로직의 분산 
     - 탈중앙화된 관리 체계 
   * 붕괴저항성, 빨리 실패하기, 자체치유 

# 02. 마이크로서비스 관련 아키텍처 스타일 및 사례 

   * 리액티브 마이크로서비스 : 회복성(resilient), 응답성(responsive), 메시지 기반(message driven), 탄력성(elastic)
    리액티브 시스템에서 각 MS는 이벤트를 리스닝한다. 서비스는 입력 이벤트르 받고 나서 반응하며, 이벤트를 처리하고 결과를 담은 응답 이벤트를 발생시킨다. 
    서비스 사이의 통신을 비동기 논블로킹(asynchronous non-blocking) 호출을 사용하는 리액티브 스타일로 설계하는 것이 중요함 
  * 마이크로서비스를 일찍 도입한 조직 
    - 넷플릭스(netflix) : 주문형 미디어 스트리밍 서비스 제공
    - 우버(Uber) : 국제 운송 네트워크 회사
    - 에어비앤비(Airbnb) : 숙박 마켓플레이스 
    - 오비츠(Orbitz) : 온라인 여행 포털
    - 이베이(eBay) : 온라인 판매자
    - 아마존 (Amazon) : 온라인 판매자
    - 길트(Gilt) : 온라인 쇼핑 사이트 
    - 트위터(Twitter) : 소셜 웹사이트 
    - 나이키 (nike) : 스포츠웨어
  * 마이크로서비스 프레임워크 
    - 횡단관심사(cross-cutting-concerns) : 외부화된 로깅, 내장HTTP리스너, 헬스체크 등 공통기능 
    - 마이크로서비스 프레임워크 : 스프링부트, 드랍위자드(Dropwizard), 와일드플라이스웜(wildfly swarm) 
    - Spring Framework5 는 리액티브 웹 프레임워크 
     
# 03. 스프링부트로 만드는 마이크로서비스 
  * 개발환경 구축 
    - JDK1.8 
    - Spring Tool Suite(STS) 3.8.2 , IntelliJ IDEA, NetBeans, Eclipse 
    - Maven 3.3.1 
    - Spring Framework 5.0.0RC1
    - Spring Boot 2.0.0.M1

https://github.com/rajeshrv/Spring5Microservice 

# 04. 마이크로서비스 개념 적용
   * 마이크로서비스 설계 가이드라인
   
      - 마이크로서비스 경계설정 

         + DDD(Domain Driven Design) : 경계 지어진 컨텍스트라는 개념 (bounnded context)
         + 경계 지어진 컨텍스트는 어떤 상위의 큰 도메인이나 시스템의 하위 도메인 또는 하위 시스템으로서 특정 기능을 수행하는 책임을 진다. 
         + 하나의 경계지어진 컨텍스트는 하나의 마이크로서비스에 대응될 수 있다.
      
      - 자율적인 기능
         자율적인 서비스는 외부기능에 대한 의존도가 낮다. 암호화엔진, 알림엔진 등 유틸리티 기능 등
      - 배포단위의 크기
         배포 단위의 크기를 관리할 수 있는 수준 이내로 유지
      - 분리하기에 가장 적합한 기능 또는 서브도메인
         자원소모량, 소유비용, 비지니스 효용성, 유연성 특면이 분석 기준이 될 수 있다.
      - 폴리그랏(polyglot) 아키텍처 
         기능/비기능요구사항 충족시키기 위해 컴포넌트마다 다른 아키텍처, 다른 기술, 다른 배포 토폴로지 등 다양한 구성으로 적용
         예) 예약MS는 Maria처럼 ACID를 준수하는 RBDMS, 검색MS는 Cassandra 와 같은 NoSQL 사용 등 
      - 선택적 확장
         확장 요구사항이 있는 마이크로서비스에 대해서만 경계를 결정
      - 애자일팀과 협력 개발
      - 단일책임 
         단일책임원칙은 메소드, 클래스 또는 서비스 수준에 적용되는 개념
         하나의 책임을 하나의 비즈니스 범위 또는 하나의 기술범위로 치환해서 생각하는 것이 더 현실적방식
         + 예) 고객 프로파일 관리 : 하나는 읽기만 전담하고 다른 하나는 쓰기만 전담하는 두개의 서로다른 마이크로서비스를 통해 고객 프로파일 관리.
         하나의 비즈니스 범위를 나눠 처리하는 CQRS(Command QUery Responsibility Segregation) 방식
      - 복제 가능성과 변경 가능성
      - 결합과 응집
         높은 결합도가 형성되지 않게 주의해야 함 
         너무 많은 정보교환, 너무 많은 동기적 요청-응답, 순환 의존 관계는 지양
         마이크로서비스 내에서 높은 응집도와 낮은 결합도를 유지해야 함

   * 통신방식 설계
     - 동기방식 통신 : 실패시 타임아웃과 fallback 처리
     - 비동기방식 통신

   * 마이크로서비스 오케스트레이션 
     - 넷플릭스는 대규모 마이크로서비스 오케스트레이션을 관리할 수 있는 오픈소스 도구인 컨덕터(conductor)를 만듬
     - 가상머신 하나당 하나의 마이크로서비스 또는 다수의 마이크로서비스? 
      가상머신이 최대 사용치를 기준으로 두개의 서비스를 운용하기에 용량이 부족한가? 
      SLA충족을 위해 서비스들이 별도로 처리돼야 하는가? 
      자원 요구사항이 서로 충돌되지는 않는가? 
      위의 질문에 No라면 하나의 가상머신에 여러개의 마이크로서비스를 실행해도 됨
     - 룰 엔진 : 공유 또는 내장?
       오픈소스 드룰즈(Drools), 상용 IBM, FICO, BOSCH
       자체 룰 엔진, 내장 룰 엔진(내부용), 룰 저장소(외부연계용) 고려해야 함
     - BPM 역할과 작업 흐름
     - 서비스 종단점 설계 고려사항 : 프로토콜 선택 (HTTP, REST, JSON메시지), API문서화(Swagger)
     - 공유 라이브러리 처리 
     - 마이크로서비스에서의 사용자 인터페이스
     - 마이크로서비스의 API 게이트웨이 

# 05. 마이크로서비스 역량 모델 
  * 핵심역량 
    하나의 마이크로서비스 안에 패키징되는 컴포넌트  
    - 서비스 리스너와 라이브러리 : HTTP, AMQP, JMS 와 같은 메시지 리스너
       + 비동기 통신을 위한 Kafka, RabbitMQ 메시지 처리 시스템
       + 메시지 종단점은 RxJava 와 같은 리액티브 클라이언트 
    2) 저장 기능
       - MySQL 과 같은 RDBMS
       - 하둡, 카산드라, Neo4J, ElasticSearch 등과 같은 NoSQL 
       - Ehcache, Hazelcast, Inpinispan 등과 같은 인메모리 저장 캐시 또는 인메모리 데이터 그리드
       - SolidDB, TimesTen 과 같은 인메모리 데이터베이스 
    3) 서비스 구현
    4) 서비스 종단점 
      - 동기방식 종단점 : REST/JSON, Avro, Thrift, Protocol Buffer등
      - 비동기방식 종단점 : 스프링 AMQP, 스프링 클라우드 스트림 등과 같은 메시지 리스너를 통해 요청을 받아서 백엔드에 있는 RabbitMQ, ZeroMQ와 같은 다른 방식의 메시징 구현체를 통해 처리

  * 인프라스트럭처역량 
    
    Redhat Openshift 와 같은 서비스로서의 플랫폼 (PaaS)
    - 클라우드 
        + 마이크로서비스에는 가상머신이나 컨테이너를 자동으로 프로비저닝할 수 있는 탄력적인 클라우드방식의 인프라스트럭처가 적합함
        + AWS, MS Azure, IBM Bluemix 등 
    - 컨테이너 런타임        
    - 컨테이너 오케스트레이션 (Orchestration) 
        + 컨테이너 런타임 위에서 일관성있는 운영환경을 제공하며, 가용한 자원을 여러 컨테이너에게 분배
        + 아파치 메소스(Mesos), Rancher, CoreOS, 쿠버네티스(Kubernetes) 등 도구 활용
        + 애플리케이션 배포, 트래픽 제어, 인스턴스 복제, 무중단 업그레이드 등을 자동으로 수행 가능
  * 지원역량 
     - 서비스게이트웨이 
       + 서비스 종단점에 대한 프록시 역할이나 여러개의 종단점을 조합하는 역할을 담당하면서 간접화 계층을 제공
       + 스프링 클라우드 Zuul, Mashery, APIgee, Kong, WSO2, 3Scale 등 
    - S/W 정의 로드밸런서
       + 새로운 서버가 운영환경에 추가되면 자동으로 감지해서 수작업없이 논리적으로 클러스터에 추가돼야 하며, 서비스 인스턴스가 서비스 불가 상태가 되면 그 인스턴스는 로드밸런서의 부하분산 대상에서 제외되어야 함
       + 스프링 클라우드 넷플릭스에 포함되어 있는 Ribbon, Eureka, Zuul을 사용해서 로드밸런서 구현 가능
    - 중앙집중형 로그관리
       + 각 서비스에서 생성되는 로그를 중앙의 로그 저장소에 적재할 수 있어야 함
    - 운영모니터링
       + 스프링 클라우드 넷플릭스, 히스트릭스 대시보드, 터바인 등 서비스 수준에서의 모니터링 
       + 서비스 전 구간을 아우르는 앱 다이내믹, 뉴렐릭, 다이나트레이스, 스탯디, 센수, 스피고 등 마이크로서비스 모니터링 
    - 신뢰성 메시지
       + RabbitMQ, ActiveMQ, Kafka 등 
       + IBM MQ, TIBCO의 EMS 등 상용제품

  * 프로세스 및 통제 역량    
    마이크로 서비스 구현에 필요한 프로세스, 도구, 가이드라인을 포함
    - 데브옵스
        애자일 개발, 신속한 변경과 배포, 자동화, 변경 관리를 지원 
        지속적 통합, 지속적 전달, 모니터링 및 로깅, 커뮤니케이션 및 협업 
    - 자동화 도구
    - 컨테이너 레지스트리 
       +  도커 허브, 구글 컨테이너 저장소, 코어OS키이(CoreOS Quay), 아마존 EC2 컨테이너 레지스트리
    - 마이크로서비스 문서화 : 스웨거, RAML, API 블루프린트
    - 참조 아키텍처 및 라이브러리 

# 06. 마이크로서비스의 진화 : 사례 연구
    * 브라운필드 항공사의 PSS 마이크로서비스 실습

# 07. 스프링 클라우드 컴포넌트를 활용한 마이크로서비스 확장
   * 스프링 클라우드 프로젝트 (https://github.com/spring-projects/spring-cloud) 
     - 분산 시스템 개발에 필요한 공통적인 패턴들을 모아 사용하기 쉬운 스프링 라이브러리 형태로 구현해서 제공
   *  스프링 클라우드 : 인터넷을 통해 들어오는 대규모의 다양한 요청을 처리할 수 있는 스프링 부트 어플리케이션을 만드는데 사용되는 개발자 키드 (developer kit)
   * 클라우드 파운드리 : 어플리케이션의 개발, 배포, 확장을 위한 오픈소스 PaaS 플랫폼
   * 주요 내용 
      - Spring Config Server : 환경설정 외부화를 담당
      - Eureka Server : 서비스 등록 및 탐색을 담당
      - Zuul : 프록시 및 게이트웨이 역할 담당
      - 마이크로서비스 자동 등록 및 서비스 탐색의 구현
      - 비동기 래액티브 마이크로서비스 구성에 필요한 스프링 클라우드 메시지
   
   * 스프링클라우드 프로젝트를 이용해서 Git Repository와 연계되는 컨피그서버,
     부하분산, 동적서비스등록 및 탐색을 위해 유레카서버 그리고 주울을 이용해서 API게이트웨이 구현해 봄 


# 08. 마이크로서비스 로깅 및 모니터링 
  * 마이크로서비스의 추적성 확보를 위한 스프링 클라우드 슬루스 (Sleuth) 
  * 서킷(sircuit) 모니터링을 위한 스프링클라우드 히스트릭스(histrix)와 터바인(turbine) 
  * 중앙 집중식 로깅 솔루션  
    - 클라우드 기반 로깅 서비스 : 로글리(loggly) 
      스프링부트 마이크로서비스는 로글리의 log4j 및 Logback appender를 이용해 로그메시지를 로글리 서비스로 직접 스트리밍할 수 있다. 
    - 내장 가능한 로깅 솔루션 
      + 그레이로그(Graylog) : 로그저장을 위해 ElasticSearch를 사용, 메타데이터저장소로 mongoDB를 사용
      + Splunk : 로그관리 및 분석에 사용되는 상용도구

   * 최상의 조합 (ELK) 
     - 로그적재기 (Logstash)
        + Logstash : 로그파일 수집, 적재를 위한 데이터 파이프라인 도구 
          서로 다른 소스에서 스트리밍 데이터를 받아 elasticSearch, HDFS, 또는 다른 DB에 저장 
     - 로그 스트림 처리기 
        + 로그 스트림을 즉시 처리하는데 사용되며, FLume, Kafka, Storm, Spark Streaming 과 함께 사용
        + 스프링 클라우드 스트림, 스프링 클라우드 스트림 모듈, 스프링 클라우드 데이터 플로우를 사용해 구축 가능 
     - 로그 저장소 (ElasticSearch)
        + 실시간 로그 메시지는 ElasticSearch에 저장되며, 클라이언트는 텍스트 기반 인덱스틀 바탕으로 쿼리할 수 있음
     - 대시보드 (Kibana)
        + 대시보드는 ElasticSearch 데이터 스토어에서 사용되는 Kibana 가 있다. 

   * 장애를 견딜 수 있는 마이크로서비스를 위한 스프링 클라우드 히스트릭스
     - 히스트릭스는 빨리 실패하고 빨리 복구하는 것을 원칙으로 함
     - Turbine을 통한 히스트릭스 스트림 통합 
     - 서킷 브레이커 패턴

# 9장. 도커 컨테이너와 마이크로서비스 

   마이크로서비스르르 컨테이너화해서 배포할 수 있다면, 하부의 인트파스트럭쳐를 포함하므로 자율적이고 클라우드 환경에 종속되지 않고 중립성을 유지할 수 있다. 
   * 컨테이너 - 운영체제 위에서 폐쇄적인 사적 공간을 제공함. 운영체제 가상화라고도 함. 컨테이너를 사용하면 운영체제의 커널이 독립적인 가상공간을 제공함. 이러한 가상 공간을 컨테이너 또는 가상엔진이라 함. 
   * 컨테이너는 호스트운영체제 위의 고립된 환경에서 프로세스 실행될 수 있게 해준다. 
     - 서버 하드웨어 > 운영체제 > N개의 컨테이너 
     컨테이너는 하나의 앱을 실행하는데 필수적인 모든 실행바이너리 파일과 라이브러리를 함께 패키징한다. 

   * 가상머신과 컨테이너의 차이 
       - 가상머신(VM) 
          + CPU, 메인보드, 메모리 등과같은 하드웨어를 가상화한다. 
          + 가상머신은 게스트OS라고 불리는 내장된 별도의 운영체제를 가진 고립된 유닛(unit)이다. 가상머신은 운영체제 전체를 복제해서 가상머신 위에서 실행하는데 이떄 호스트운영체제 환경에 전혀 의존하지 않는다. 
          + 가상머신이 운영체제 전체를 내장하고 있기 떄문에 가상머신은 본질적으로 무겁다.
          + 가상머신 스택 : 서버H/W > 호스트운영체제> 하이퍼바이저 > 게스트OS > 앱bin/lib 
       - 컨테이너
         + 컨테이너는 호스트운영체제 위에서 고립된 실행환경을 제공함
         + 컨테이너 스택 : 서버H/W > 호스트운영체제 > 컨테이너S/W > 앱bin/lib   

   * 컨테이너의 장점
       - 자기완비적 : App실행바이너리와 의존하는 모든 라이브러리를 포함하고 있어서 개발, 테스트, 운영환경을 패키징하여 포함
       - 경량성 : 작은 공간 사용, 신속하게 구동할 수 있고 컨테이너를 만들고 탑재,저장이 쉽다.
       - 확장성 : OS부팅이 필요없으므로 빠른 실행, 클라우드에 친화적 
       - 이식성 : 장비간 또는 클라우드 서비스간 이식 가능 
       - 저렴한 라이선스 비용 : S/W라이선스가 물리적 코어에 비례해 책정되어 있는데, 컨테이너는 OS를 공유하므로 상대적으로 라이선스비용이 덜 든다.
       - 데브옵스 : 빌드, 퍼블리싱, 원격 저장소에서의 다운로드를 자동화하기 쉽다. 
       - 버전관리 : 컨테이너도 버전관리 산출물로 만들 수 있다.
       - 재사용성 : 특수목적의 라이브러리 조합으로 만들어진 컨테이너 이미지를 재사용할 수 있다.
       - 불변 컨테이너 : 생성되고 사용후에 폐기

   * 마이크로서비스와 컨테이너

     - 마이크로서비스들은 OS는 공유하지만 각자의 실행환경은 추상화해서 스스로 보유하고 있다. 
     - 컨테이너는 여러개의 폴리그랏언어로 개발된(Java, Erlang, python등) 마이크로서비스를 운영할때 진가를 발휘한다.
     - 사용된 기술에 상관없이 컨테이너화된 마이크로서비스는 REST API를 제공한다. - 컨테이너가 시작되어 실행되면 어떤 특정 포트에 바인딩되고 그 포트를 통해 API를 외부에 공개한다. 

   * 도커 및 도커 핵심컴포넌트

     리눅스 커널 기반으로 가벼운 컨테이너를 만들고 탑재하고 실행할 수 있는 플랫폼이다. 
     - 도커 데몬 : 호스트 장비 위에 설치되는 서버 측 컴포넌트로서 도커 컨테이너를 만들고 실행하고 배포하는 역할 담당. 도커 클라이언트를 위한 REST API를 외부에 노출, 도커 클라이언트와 상호작용할 수 있음. 
     - 도커 클라이언트 : 소켓이나 REST API를 통해 도커 데몬과 상호작용할 수 있는 커맨드라인 인터페이스(CLI) 프로그램  
        도커 사용자는 CLI를 통해 도커 컨테이너를 만들고 탑재, 실행할 수 있다.
     - 도커 이미지 : 운영체제 라이브러리, 애플리케이션 및 의존라이브러리의 읽기 전용 복사본임.  
        스프링 부트 마이크로서비스에서는 도커 이미지가 우분투, 알파인 같은 운영체제, JRE, 스프링 부트 애플리케이션 JAR 파일을 모두 이미지 안에 패키징한다. 또한 애플리케이션을 실행하고 서비스를 외부에 노출하는 명령들도 포함한다. 
        + 운영체제 > 자바런타임 > 스프링부트 어플리케이션 Jar파일 
     - 도커 컨테이너 : 실행중인 도커 이미지의 인스턴스 
     - 도커 레지스트리 : 도커이미지를 퍼블리싱하고 다운로드할 수 있는 중앙저장소임. 도커허브(http://hub.docker.com) 는 도커에 의해 제공되는 중앙저장소
     - 도커파일(Dockerfile) : 도커이미지를 만들 수 있는 명령어를 포함하고 있는 빌드파일 또는 스크립트 파일. 도커파일은 maven의 pom.xml에 해당
   
     - 마이크로서비스를 도커에 배포
       1) 도커 설치 후 docker.app실행해서 정상설치여부 확인
       2) 모든 서비스의 application.properties 파일의 IP를 DNS나 로드밸러서의 IP로 주소 지정 
       3) 모든 서비스의 루트디렉토리에서 dockerfile 생성 
        
        + 예시
     
         FROM frolvlad/alpine-oraclejdk8               
         // 도커에게 jdk버전으로 도커이미지를 생성하란 의미
         VOLUME /tmp                                  
         // 컨테이너가 /tmp접근할 수 있게 해줌. 톰캣을 위한 작업 디렉토리를 생성하는 곳
         ADD target/search-1.0.jar search.jar         
         // 실행파이너리파일을 컨테이너에 추가 
         EXPOSE 8090                                  
         // 스프링부트서비스를 호스트의 8090으로 바인딩
         ENTRYPOINT ["java","-jar","/search.jar"]     
         // 컨테이너가 시작할때 실행되는 어플리케이션 지정
          
         $docker build -t search:1.0                
         // 검색서비스를 위한 docker image 생성 

         $docker images                              
         // 도커이미지 확인
         $docker run -p 8090:8090 -t search:1.0    
         // 컨테이너 로딩 및 스프링부트 실행
         $docker run rabbitmq                         
         // rabbitmq 실행
         $docker ps                                   
         // 프로세스 실행여부 확인
         http://localhost:8001                       
         // 브라우저 웹사이트 접속  
         
      - 도커 레지스트리 사용 
         $docker run  -d -p 5000:5000 --restart=always --name registry registry:latest          
         // 5000번 포트로 레지스트리 시작
         $docker tag search:1.0 localhost:5000/search:1.0      
         //도커이미지에 search tag붙인다
         $docker push localhost:5000/search:1.0             
         //도커이미지를 레지스트리에 푸시
         $docker pull localhost:5000/search:1.0             
         //도커이미지를 레지스트리에서 다운로드

      - 도커 허브 구성 
         http://docs.docker.com/engine/installation 

      - 도커 허브에 마이크로서비스 퍼블리싱
         $docker tag search:1.0 brownfield/search:1.0
         $docker push brownfield/search:1.0
         https://hub.docker.com/u/brownfield

   * 클라우드에서의 마이크로서비스 
      - AWS EC2에 도커 설치
         1) EC2 인스턴스를 띄운다
         2) EC2 에 연결해서 다음 명령 실행
            $sudo apt-get update
            $sudo apt-get install docker.io 
         3) 설치 확인
            $sudo docker version
            
      - EC2에서 브라운필드 서비스 실행 
         1) .properties 파일에 EC2인스턴스의 IP주소 반영
         2) 로컬장비에서 프로젝트 compile 및 도커이미지 생성, 허브 레지스트에 푸시
         3) EC2 인스턴스에 hjava8설치 
         4) 실행 
            $sudo docker run --net=host rabbitmq:3
            $sudo docker run -p 8090:8090 rajeshrv/search:1.0
            $sudo docker run -p 8001:8001 rajeshrv/website:1.0 
         5) EC2인스턴스 공용IP 웹사이트 접속
            http://xx.xx.xx.xx:8001 


# 10장. 메소스와 마라톤을 이용한 도커화된 마이크로서비스 확장
   
   클라우드환경에서 마이크로서비스를 배포하고 운영할때 자원사용량을 최적화할 수 있게 메소스(Mesos)를 인프라스트럭처 추상화 계층으로 하고, 마라톤(Marathon)을 클러스터 제어시스템으로 사용하는 방법

   * 컨테이너 오케스트레이션 솔루션
      - 도커 스웜(Docker Swarm)
      - 쿠버네티스(Kubernetes) : 구글 Go언어로 만들어짐
        + 여러 노드들의 클러스터에 걸쳐 컨테이너화된 어플리케이션을 관리하는데 도움을 주는 도구로서 컨테이너 배포 자동화, 스케줄링, 컨테이너 확장을 자동화해 줌
        + 쿠버네티스는 마스터와 노드로 클러스터를 형성한다.  
        + 노드는 여러개의 팟(pod)으로 나눌 수 있으며 하나 이상의 컨테이너가 팟 안에서 그룹화되어 실행됨
        
      - 아파치 메소스(Mesos) : UC버클리대학에서 개발되어 트위터에서 확장된 오픈소스 프레임워크임. 
        + 다수의 컴퓨터를 하나의 큰 장비로 논리적으로 그룹화하고 가상화해주는 분산 시스템 커널이다. 
        + 메소스는 다수의 이기종 자원을 어플리케이션이 배포될 수 있는 하나의 균일한 자원 클러스터로 그룹화할 수 있기 때문에 데이터센터에서 사설 클라우드를 구축할 수 있게 해주는 도구로 사용됨. 
        + 메소스는 마스터노드와 슬레이브 노드로 구성되며, 클러스터 코디네이션을 위해 주키퍼(zookeeper)를 사용함
      

   * 메소스와 마라톤을 이용한 컨테이너 오케스트레이션
      - 쿠버네티스
      - 마라톤 같은 프레임워크를 장착한 메소스 

         + 메소스는 저수준의 물리적 장비 또는 가상머신에 있는 CPU, 메모리, 저장장치와 같은 저수준 컴퓨팅 자원을 추상화함

         + 메소스 아키텍처
            핵심컴포넌트 : 마스터노드, 슬레이브노드, 주키퍼, 메소스프레임워크(스케줄러, 실행자) 

            프레임워크 스케줄러 -> 메소스 마스터노드 <- 주키퍼 
                                    ↓         ↓  
            프레임워크실행자(메소스슬레이브노드)  프레임워크실행자(메소스슬레이브노드)  
         
         + 마라톤 주요기능
           자원제약사항 설정
           확장(scale-up), 축소(scale down)와 어플리케이션 관리
           어플리케이션 버전관리, 시작 및 종료

  * 브라운필드 마이크로서비스에 메소스와 마라톤 적용
      - 메소스, 마라톤과 관련 컴포넌트 설치
         https://mesos.apache.org/gettingstarted 

      - 도커 설치
         $sudo apt-get update
         $sudo apt-get install docker.io
         $sudo docker version

      - 마라톤 설치
         $curl -O http://downloads.mesosphere.com/marathon/v1.4.3/marathon-1.4.3.tgz
         $tar xzf marathon-1.4.3.tgz 

      - 주키퍼 설치 
         $wget http://ftp.unicamp.br/pub/apache/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz
         $tar -xzvf zookeeper-3.4.9.tar.gz
         $rm -rf zookeeper-3.4.9.tar.gz
         $cd zookeeper-3.4.9
         $cd zoo_sample.cfg zoo.cfg

      - 메소스와 마라톤 실행 
         ubuntu@~zookeeper-3.4.9>sudo -E bin/zkServer.sh start
         ubuntu@~mesos-1.2.0/build/bin>./mesos-master.sh --work_dir=/hme/ubuntu/mesos-1.2.0/build/mesos-server
         ubuntu@~marathon-1.4.3> MESOS_NATIVE_JAVA_LIBRARY/home/ubuntu/mesos-1.2.0/build/src/.ubuntu@~mesos-1.2.0/build>sudo ./bin/mesos-agent.sh 

         http://ec2-xx.amazonaws.com:5050     //메소스 콘솔화면 (cluseter, agent, task 정보)
         http://ec2-xx.amazonaws.com:8080    //마라톤 UI (어플리케이션 정보)


# 11장. 마이크로서비스 개발 라이프사이클
   * 개발 라이크사이클 프로세스로서의 데브옵스 
      - 지속적 통합 (Continuous Integration) 
         정해진 시간 간격으로 또는 개발자의 소스 커밋에 의해 지속적으로 수행
      - 지속적 전달 (Continuous Delivery) 
         CD는 CI의 진화된 후속 버전으로 CI의 통합파이프라인에 QA사이클을 추가해 소프트웨어 제품 출시 준비된 상태로 만들어 준다
      - 지속적 배포 (Continuous Deployment)
         어플리케이션 바이너리를 하나 혹은 그 이상의 환경에 배포하고 환경설정 관련 파라미터와 함께 관리하는 것을 자동화하는 방식
      - 어플리케이션 출시 자동화 (Application Release Automation)
         제품 전달 파이프라인 전체를 모니터링하는 도구

      - 마이크로 서비스 개발을 위한 데브옵스 프로세스 
         + 가치 주도 계획 -> 애자일 개발 -> 지속적 통합 -> 지속적 테스팅 -> 지속적 출시 -> 지속적 모니터링 및 피드백
           (지속적 전달 , 지속적 통합, 지속적 배포)

   * 개발 사이클 자동화
      - 지속적 전달 파이프라인 단계 
        + 개발 -> 통합(스프링 클라우드, 도커) -> (기능/보안/성능)테스트(스프링 클라우드, 도커) -> 인수테스트(스프링 클라우드, 도커) -> 스테이징(스프링 클라우드, 도커)
      - 개발
         + 소스코드 : eclipse IDE, SonarQube
         + 단위테스트 : junit
         + 소비자 주도 계약 : 테스트케이스를 위한 junit
         + Mock 테스트 :
         + 행위주도설계 : 기능테스트, 사용자시나리오테스트, 인수테스트 
         + 소스코드 저장소 : Git, Subversion
         + 산출물 저장소 : Nexus 
         + 데이터베이스 스키마 : 리퀴베이스(Liquibase), 플라이웨이(Flyway)
      - 통합 
         + Jenkins, Bamboo
      - 테스트
         + 새너티 테스트(sanity test) : 하나의 환경에서 다른 환경으로 옮길때 모든 기본동작이 제대로 실행되는지 확인 
         + 회귀테스트 : 변경사항이 기존 시스템에 영향이 없는지 확인
         + 기능테스트 : 회귀와 기능테스트를 동일한 테스트케이스를 가진 하나의 단계로 조합
         + 인수테스트 
         + 성능테스트 
         + 보안테스트
         + 비기능테스트
      - 배포       
      - 모니터링과 피드백
      
-------------------------------------------------------------------------------------
# Nara-Platform 

  * tenant : 조직, 조직도, 구성원, 작업공간 
  * 서비스 구독 : 앱스토어. 사용자 기능을 앱형식으로 제공
    - 앱은 워크스페이스 단위로 구독(subscription), 필요한 기능 구독/취소. 작업자의 역할에 따라 접근 제어 
  * 접근제어 : 사용자 인증과 역할에 따른 사용자 접근을 조절하며, 요청 관련 필요한 정보를 주입하여 앱에서 사용
  * 역할 매핑 : 역할기반접근제어(Role-Based Access Control) 
  * 작업공간(workspace) :  하나의 시스템에서 서로 다른 어플리케이션을 사용하는 듯한 효과임. 각 공간에서 그 공간에서 필요한 서비스를 구독하여 사용
  * Nara 드라마 : iOS나 안드로이드에 기본앱이 있는 것과 유사함. 12개의 공유앱이 앱스토어에 있음. 
    - 예)board, checklist, feedback, flow, party, profile, talk, task 등 
  * 드라마 명세서 : 서비스명세와 설계, 코딩을 위한 안내서로서 참조모델역할
  * 서비스 독립성 : 앱스토어를 통해서 배포되는 앱을 드라마라고 함
  * 세션 컨텍스트 : 기능 수행을 위해 사용자/조직/요청 컨텍스트 정보 필요
    기존 어플리케이션 개발에서는 세션이라는 곳에 요청 관련 제한된 수준의 정보를 저장하였음. Stage 는 사용자/조직/구성원/요청/공유자료 등에 대한 모든 정보를 API로 제공하는 세션 컨텍스트임. 앱은 고유의기능 개발에 집중하고 서비스 수행에 필요한 모든 정보를 Stage API를 호출하여 가져옴
  * App 생태계 : Private 앱스토어 . SaaS 
    - NARA플랫폼은 MSA 기반 서비스 플랫폼이면서 앱스토어를 갖고 있음

  ※ 플랫폼 기반 앱스토어 비교
  
     - salesforce.com : 앱 익스체인지
     - 애플 : 앱스토어
     - 구글 : 플레이 스토어
     - 마이크로소프트 : 앱스토어
     - saleforce.com : SFA/CRM SaaS 
     - Nara 플랫폼 : 앱스토어 (Art Center) 
     
--------------------------------------------------------------------------------------

# Git Bash 에서 npm 사용

$npm install -g mark2html    
// markdown -> html 변환기 설치하면 nodejs 아래 폴더에 설치된다. 
$ cd '/c/Program Files/nodejs/node_modules/mark2html'
$ mark2html -s /d/작업방/Spring5Microservice-master/Spring5Microservices-2e.md -d /c/temp/markdown2.html

# 간단한 markdown 문법 
* 1단계
    - 2단계
    	+ 3단계
        = 4단계
